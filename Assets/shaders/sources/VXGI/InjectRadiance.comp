#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../Common/Math.h"
#include "../Common/Light.h"

const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;

layout(set = 0, binding = 0) uniform sampler3D uVoxelAlbedo;
layout(set = 0, binding = 1, rgba8) uniform image3D uVoxelNormal;
layout(set = 0, binding = 2, rgba8) uniform writeonly image3D uVoxelRadiance;
layout(set = 0, binding = 3, rgba8) uniform readonly image3D uVoxelEmissive;
layout(set = 0, binding = 4) uniform sampler2DArray uShadowMap;
layout(set = 0, binding = 5) uniform UniformBufferLight
{
	Light lights[MAX_LIGHTS];
    mat4 viewMatrix;
    mat4 shadowTransform[MAX_SHADOWMAPS];
	mat4 lightView;
	mat4 biasMat;
    vec4 splitDepths[MAX_SHADOWMAPS];
    
    float initialBias;
    int lightCount;
    int shadowCount;
    int padding;
}ubo;

layout(set = 0, binding = 6) uniform UniformBufferVX
{
    vec4 worldMinPoint;
    float lightBleedingReduction;
    float voxelSize;
    float voxelScale;
    float traceShadowHit;
	int volumeDimension;
    int normalWeightedLambert;//default is 1
    int shadowingMethod;
    int padding;
}uboVX;

vec3 voxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= uboVX.voxelSize;
    return result + uboVX.worldMinPoint.xyz;
}

vec3 worldToVoxel(vec3 position)
{
    vec3 voxelPos = position - uboVX.worldMinPoint.xyz;
    return voxelPos * uboVX.voxelScale;
}

//slow....
float traceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
    // scaling factor
    float k = uboVX.traceShadowHit * uboVX.traceShadowHit;
    float voxelTexSize = 1.0f / uboVX.volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    float visibility = 0.0f;
    float traceSample = 0.0f;

    while (visibility <= 1.0f && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
        { 
            break; 
        }
        traceSample = ceil(texture(uVoxelAlbedo, samplePos).a) * k;
        // hard shadows mode
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }
        // accumulate
        visibility += (1.0f - visibility) * traceSample / dst;
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }
    return 1.0f - visibility;
}


float textureProj(vec4 shadowCoord, vec2 offset, int cascadeIndex)
{
	float shadow = 1.0;
	float ambient = 0.0;
	
	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 && shadowCoord.w > 0)
	{
		float dist = texture(uShadowMap, vec3(shadowCoord.st + offset, cascadeIndex)).r;
		if (dist < (shadowCoord.z - ubo.initialBias))
		{
			shadow = ambient;//dist;
		}
	}
	return shadow;
}

float visibility(vec3 position)
{
    int cascadeIndex = calculateCascadeIndex(
        ubo.viewMatrix,position,ubo.shadowCount,ubo.splitDepths
    );

    vec4 shadowCoord = (ubo.biasMat * ubo.shadowTransform[cascadeIndex]) * vec4(position, 1.0f);
    if(shadowCoord.w == 0.0f) return 1.0f;
    //ndc-space
    shadowCoord /= shadowCoord.w;
    return textureProj(shadowCoord, vec2(0,0), cascadeIndex);
}

vec3 BRDF(Light light, vec3 normal, vec3 albedo)
{
    float nDotL = 0.0f;

    if(uboVX.normalWeightedLambert == 1)
    {
        vec3 weight = normal * normal;
        // calculate directional normal attenuation
        float rDotL = dot(vec3(1.0, 0.0, 0.0), light.direction.xyz);
        float uDotL = dot(vec3(0.0, 1.0, 0.0), light.direction.xyz);
        float fDotL = dot(vec3(0.0, 0.0, 1.0), light.direction.xyz);

        rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
        uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
        fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
        // voxel shading average from all front sides
        nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;
    }
    else
    {
        nDotL = max(dot(normal, light.direction.xyz), 0.0f);
    }
    
    float intensity = pow(light.intensity, 1.4) + 0.1;
    return intensity * light.color.rgb * albedo * nDotL;
}

vec4 calculateDirectional(Light light, vec3 normal, vec3 position, vec3 albedo)
{
    float v = 1.0f;

    if(uboVX.shadowingMethod == 1)
    {
        v = visibility(position);
    }
    else if(uboVX.shadowingMethod == 2)
    {
        vec3 voxelPos = worldToVoxel(position);
        v = traceShadow(voxelPos, light.direction.xyz, 1.0f);
    }

    if(v == 0.0f) return vec4(0.0f); 

    return vec4(BRDF(light, normal, albedo) * v, v);
}

vec4 calculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo)
{
    light.direction.xyz = light.position.xyz - position;
    float d = length(light.direction.xyz);
    light.direction = normalize(light.direction);

    float atten = light.radius / (pow(d, 2.0) + 1.0);

    if(atten <= 0.0f) return vec4(0.0f);

    float visibility = 1.0f;

    if(uboVX.shadowingMethod == 2)
    {
        vec3 voxelPos = worldToVoxel(position);
        vec3 lightPosT = worldToVoxel(light.position.xyz);

        vec3 lightDirT = lightPosT.xyz - voxelPos.xyz;
        float dT = length(lightDirT);
        lightDirT = normalize(lightDirT);

        visibility = traceShadow(voxelPos, lightDirT, dT);
    }    

    if(visibility <= 0.0f) return vec4(0.0f); 

    return vec4(BRDF(light, normal, albedo) * atten * visibility, visibility);
}

vec4 calculateSpot(Light light, vec3 normal, vec3 position, vec3 albedo)
{
    vec3 spotDirection = light.direction.xyz;
    light.direction.xyz = normalize(light.position.xyz - position);
    float cosAngle = dot(-light.direction.xyz, spotDirection);

    float dst = distance(light.position.xyz, position);

    float cutoffAngle = 1.0f - light.angle; 
    float epsilon = cutoffAngle - cutoffAngle * 0.9f;
    float attenuation 	= ((cosAngle - cutoffAngle) / epsilon);
    attenuation*= light.radius / (pow(dst, 2.0) + 1.0);
    float value = clamp(attenuation, 0.0, 1.0);

    float visibility = 1.0f;

    if(uboVX.shadowingMethod == 2)
    {
        vec3 voxelPos = worldToVoxel(position);
        vec3 lightPosT = worldToVoxel(light.position.xyz);
        vec3 lightDirT = lightPosT.xyz - voxelPos.xyz;
        float dT = length(lightDirT);
        lightDirT = normalize(lightDirT);
        visibility = traceShadow(voxelPos, lightDirT, dT);
    }    

    if(visibility <= 0.0f) return vec4(0.0f);

    return vec4(BRDF(light, normal, albedo) * value * visibility, visibility);
}

vec4 calculateDirectLighting(vec3 position, vec3 normal, vec3 albedo)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.0 /  (uboVX.voxelScale * uboVX.volumeDimension);
    
    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f); 
    int count = 0;
	// move position forward to avoid shadowing errors
    position = position + normal * voxelWorldSize * 0.5f;

    // calculate lighting for directional lights
    for(int i = 0; i < ubo.lightCount; i++)
    {
        Light light = ubo.lights[i];
        if( light.type == 2.0 )
        {
            current = calculatePoint(light, normal, position, albedo);
        }
        else if( light.type == 1.0 )
        {
            current = calculateSpot(light, normal, position, albedo);
        }
        else
        {
            current = calculateDirectional(light, normal, position, albedo);
        }
       
        directLighting.rgb += current.rgb;
        directLighting.a += current.a; 
        count++;
    }

    if(count > 0) { directLighting.a /= count; }

    return directLighting;
}

vec3 encodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 decodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}

void main()
{
	if(gl_GlobalInvocationID.x >=  uboVX.volumeDimension ||
		gl_GlobalInvocationID.y >= uboVX.volumeDimension ||
		gl_GlobalInvocationID.z >= uboVX.volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);
	vec4 albedo = texelFetch(uVoxelAlbedo, writePos, 0);

    if(albedo.a < EPSILON) { return; }

    albedo.a = 0.0f;
    // voxel normal in 0-1 range
    vec3 baseNormal = imageLoad(uVoxelNormal, writePos).xyz;
    // normal is stored in 0-1 range, restore to -1-1
    vec3 normal = decodeNormal(baseNormal);
    // emission from voxel
    vec3 emissive = imageLoad(uVoxelEmissive, writePos).rgb;

    // black voxel has no irradiance diffuse
    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        // obtain world-space position of the current voxel
        vec3 wsPosition = voxelToWorld(writePos);
        // calculate direct lighting onto voxel
        albedo = calculateDirectLighting(wsPosition, normal, albedo.rgb);
    }

    // store visibility in normal alpha
    imageStore(uVoxelNormal, writePos, vec4(baseNormal, albedo.a));
    // add emission
    albedo.rgb += emissive;
    albedo.a = 1.0f;
	imageStore(uVoxelRadiance, writePos, albedo);
}